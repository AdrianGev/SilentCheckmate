import React, { useState, useEffect, useRef } from 'react';
import ChessBoard from './ChessBoard';
import GameControls from './GameControls';
import GameInfo from './GameInfo';
import '../styles/App.css';

const App = () => {
  // State variables
  const [username, setUsername] = useState(localStorage.getItem('username') || 'Player');
  const [gameId, setGameId] = useState(null);
  const [opponent, setOpponent] = useState(null);
  const [playerColor, setPlayerColor] = useState('white');
  const [status, setStatus] = useState('Ready to play');
  const [moveHistory, setMoveHistory] = useState([]);
  const [isGameActive, setIsGameActive] = useState(false);
  const [position, setPosition] = useState('start');
  const [isGameOver, setIsGameOver] = useState(false);
  const [gameResult, setGameResult] = useState(null);
  const [socket, setSocket] = useState(null);
  
  const chessBoardRef = useRef(null);
  
  // Request notification permissions
  useEffect(() => {
    if ('Notification' in window && Notification.permission !== 'granted' && Notification.permission !== 'denied') {
      Notification.requestPermission();
    }
  }, []);
  
  // Initialize WebSocket connection
  useEffect(() => {
    const serverUrl = localStorage.getItem('SERVER_URL') || 'https://silentcheckmate.onrender.com';
    const wsUrl = serverUrl.replace(/^http/, m => m === "https" ? "wss" : "ws") + "/ws";
    
    const newSocket = new WebSocket(wsUrl);
    
    newSocket.onopen = () => {
      console.log("WebSocket connected");
      setStatus("Connected to server");
      
      // Send login message with username if available
      if (username) {
        newSocket.send(JSON.stringify({ type: "LOGIN", payload: { username } }));
      }
      
      // Keep-alive ping
      const pingInterval = setInterval(() => {
        if (newSocket.readyState === 1) {
          newSocket.send(JSON.stringify({ t: "PING" }));
        }
      }, 25000);
      
      // Store interval ID for cleanup
      newSocket.pingInterval = pingInterval;
    };
    
    newSocket.onmessage = (event) => {
      try {
        const message = JSON.parse(event.data);
        handleSocketMessage(message);
      } catch (error) {
        console.error("Error parsing message:", error);
      }
    };
    
    newSocket.onclose = () => {
      console.log("WebSocket disconnected");
      setStatus("Disconnected from server. Reconnecting...");
      clearInterval(newSocket.pingInterval);
      
      // Reconnect after a delay
      setTimeout(() => {
        setSocket(null); // This will trigger the useEffect to run again
      }, 2000);
    };
    
    newSocket.onerror = (error) => {
      console.error("WebSocket error:", error);
      setStatus("Connection error");
    };
    
    setSocket(newSocket);
    
    // Cleanup on unmount
    return () => {
      if (newSocket) {
        clearInterval(newSocket.pingInterval);
        newSocket.close();
      }
    };
  }, [username]); // Re-run when username changes or socket is null
  
  // Handle WebSocket messages
  const handleSocketMessage = (message) => {
    console.log("Received message:", message);
    
    // Handle new message format (t property)
    if (message.t) {
      handleNewFormatMessage(message);
      return;
    }
    
    // Handle legacy message format (type property)
    if (message.type) {
      handleLegacyMessage(message);
    }
  };
  
  // Handle new message format
  const handleNewFormatMessage = (message) => {
    switch (message.t) {
      case "STATE":
        // Update board position
        setPosition(message.fen);
        
        // Add move to history if available
        if (message.last) {
          setMoveHistory(prev => [...prev, message.last]);
          setStatus(`Last move: ${message.last}`);
        }
        break;
        
      case "ILLEGAL":
        setStatus("Illegal move attempted");
        break;
        
      case "PONG":
        // Ping response, nothing to do
        break;
        
      default:
        console.log("Unknown message type:", message.t);
    }
  };
  
  // Handle legacy message format
  const handleLegacyMessage = (message) => {
    const { type, payload } = message;
    
    switch (type) {
      case 'CONNECTED':
        console.log('Connected to server');
        break;
        
      case 'LOGIN_SUCCESS':
        console.log('Login successful');
        break;
        
      case 'GAME_CREATED':
        setGameId(payload.gameId);
        setPlayerColor('white');
        setStatus(`Game created. Waiting for opponent.`);
        
        // Show a notification to highlight the game ID
        if (payload.gameId) {
          // Use browser notification if available and permitted
          if ('Notification' in window && Notification.permission === 'granted') {
            new Notification('Game Created', {
              body: `Share this Game ID with your opponent: ${payload.gameId}`,
              icon: '/favicon.ico'
            });
          }
          
          // Also show an alert for browsers without notification support
          setTimeout(() => {
            alert(`Game created! Your Game ID is: ${payload.gameId}\n\nShare this ID with your opponent so they can join your game.`);
          }, 500);
        }
        break;
        
      case 'GAME_JOINED':
        setGameId(payload.gameId);
        setPlayerColor('black');
        setOpponent(payload.creator);
        setIsGameActive(true);
        setStatus(`Game started. Playing as black against ${payload.creator}`);
        break;
        
      case 'OPPONENT_JOINED':
        setOpponent(payload.opponent);
        setIsGameActive(true);
        setStatus(`Game started. Playing as white against ${payload.opponent}`);
        break;
        
      case 'MOVE_MADE':
        // The board will be updated via the STATE message
        break;
        
      case 'GAME_OVER':
        setIsGameActive(false);
        setIsGameOver(true);
        
        if (payload.reason === "checkmate") {
          if (payload.winner === username) {
            setStatus("Checkmate! You won!");
            setGameResult("win");
          } else {
            setStatus("Checkmate! You lost.");
            setGameResult("loss");
          }
        } else if (payload.reason === "draw" || payload.reason === "stalemate" || payload.reason === "draw_agreement") {
          setStatus(`Game ended in a draw (${payload.reason}).`);
          setGameResult("draw");
        } else if (payload.reason === "resignation") {
          if (payload.winner === username) {
            setStatus(`${payload.loser} resigned. You won!`);
            setGameResult("win");
          } else {
            setStatus("You resigned.");
            setGameResult("loss");
          }
        } else {
          setStatus(`Game over: ${payload.reason}`);
        }
        break;
        
      case 'DRAW_OFFERED':
        setStatus(`${payload.offeredBy} offered a draw.`);
        // Show draw offer dialog (could be implemented with a modal)
        break;
        
      case 'DRAW_DECLINED':
        setStatus(`${payload.declinedBy} declined the draw offer.`);
        break;
        
      case 'OPPONENT_DISCONNECTED':
        setStatus(`${payload.opponent} has disconnected.`);
        setIsGameActive(false);
        break;
        
      case 'ERROR':
        setStatus(`Error: ${payload.message}`);
        break;
        
      default:
        console.log("Unknown message type:", type);
    }
  };
  
  // Create a new game
  const createGame = () => {
    if (socket && socket.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify({ type: "CREATE_GAME" }));
      setStatus("Creating new game...");
    } else {
      setStatus("Not connected to server. Please try again.");
    }
  };
  
  // Join an existing game
  const joinGame = (id) => {
    if (socket && socket.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify({ type: "JOIN_GAME", payload: { gameId: id } }));
      setStatus(`Joining game ${id}...`);
    } else {
      setStatus("Not connected to server. Please try again.");
    }
  };
  
  // Reset the board
  const resetGame = () => {
    setPosition("start");
    setMoveHistory([]);
    setStatus("Board reset");
    
    // If in a game, rejoin to get the current state
    if (isGameActive && gameId && socket && socket.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify({ t: "JOIN", gameId }));
    }
  };
  
  // Resign from the current game
  const resignGame = () => {
    if (isGameActive && gameId && socket && socket.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify({ type: "RESIGN", payload: { gameId } }));
      setStatus("You resigned");
    }
  };
  
  // Offer a draw
  const offerDraw = () => {
    if (isGameActive && gameId && socket && socket.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify({ type: "OFFER_DRAW", payload: { gameId } }));
      setStatus("You offered a draw");
    }
  };
  
  // Handle move from the chessboard
  const handleMove = (move, fen) => {
    if (isGameActive && gameId && socket && socket.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify({
        type: "MAKE_MOVE",
        payload: {
          gameId,
          move: move.san,
          fen
        }
      }));
    }
  };
  
  return (
    <div className="app-container">
      <header className="app-header">
        <h1>SilentCheckmate</h1>
        <div className="user-info">
          <span className="username">{username}</span>
        </div>
      </header>
      
      <main className="app-content">
        <div className="board-container">
          <ChessBoard
            ref={chessBoardRef}
            position={position}
            orientation={playerColor}
            onMove={handleMove}
            gameId={gameId}
            socket={socket}
            disabled={!isGameActive}
          />
        </div>
        
        <div className="side-panel">
          <GameControls
            createGame={createGame}
            joinGame={joinGame}
            resetGame={resetGame}
            resignGame={resignGame}
            offerDraw={offerDraw}
            isGameActive={isGameActive}
            gameId={gameId}
            playerColor={playerColor}
          />
          
          <GameInfo
            username={username}
            opponent={opponent}
            status={status}
            gameId={gameId}
            playerColor={playerColor}
            moveHistory={moveHistory}
            isGameOver={isGameOver}
            result={gameResult}
          />
        </div>
      </main>
    </div>
  );
};

export default App;
